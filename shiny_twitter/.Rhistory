" 'Net Income1','Cash Dividend1','Dividend1','Quarter PER1','Quarter PBR1']\n",
"\n",
"combination_dict = {}\n",
"for c in combination:\n",
"    combination_dict[c] = []\n",
"\n",
"size = len(raw_data)\n",
"\n",
"for s in range(size):\n",
"    for c,nc in zip(combination,non_combination):\n",
"        if (not pd.isnull(raw_data[c][s]))and (not pd.isnull(raw_data[nc][s])):\n",
"            combination_dict[c].append(raw_data[c][s])\n",
"        elif (pd.isnull(raw_data[c][s])) and (not pd.isnull(raw_data[nc][s])):\n",
"            combination_dict[c].append(raw_data[nc][s])\n",
"        elif pd.isnull(raw_data[c][s]) and pd.isnull(raw_data[nc][s]):\n",
"            combination_dict[c].append(np.nan)\n",
"        elif (not pd.isnull(raw_data[c][s])) and ( pd.isnull(raw_data[nc][s])):\n",
"            combination_dict[c].append(raw_data[c][s])\n",
"\n",
"raw_data = raw_data.drop((combination+non_combination), 1)\n",
"raw_data = raw_data.join(pd.DataFrame(combination_dict))\n",
"raw_data = raw_data[pd.notnull(raw_data['Closing Price'])]\n",
"raw_data = raw_data[pd.notnull(raw_data['Date'])]\n",
"\n",
"raw_data[\"Date\"] = pd.to_datetime(raw_data['Date'], format='%Y/%m/%d')\n",
"raw_data[\"TSE Public Date\"] = pd.to_datetime(raw_data['TSE Public Date'], format='%Y/%m/%d')\n",
"raw_data = raw_data[(raw_data[\"Date\"]  > raw_data[\"TSE Public Date\"]) | (raw_data[\"TSE Public Date\"].isnull())]"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"error_code = []\n",
"for code in code_name:\n",
"    tmp = [a.month for a in raw_data[raw_data['Security Code'] == code]['Date']]\n",
"    for a in range(len(tmp)-1):\n",
"        if int(tmp[a]) == 1:\n",
"            if not int(tmp[a])-1 == 12:\n",
"                error_code.append(code)\n",
"                break\n",
"        else:\n",
"            if not int(tmp[a])-1 == int(tmp[a+1]):\n",
"                error_code.append(code)\n",
"                break        "
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"error_code"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"len(code_name)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"with open('/Users/wy/Desktop/stock_work/stock.pickle', 'wb') as f:\n",
"    pickle.dump(raw_data, f)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": []
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"with open('/Users/wy/Desktop/stock_work/stock.pickle', 'rb') as f:\n",
"    raw_data = pickle.load(f)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"def check_NaN_convert_float(x):\n",
"    if pd.isnull(x):\n",
"        return x\n",
"    else:\n",
"        if type(x) == str:\n",
"            return float(x.replace(',', ''))\n",
"        else:\n",
"            return float(x)\n",
"    \n",
"datetime_object = [\"Dividend Confirm \",'Stock Dividend Pay','Cash Dividend Pay']\n",
"for date_ob in datetime_object:\n",
"    raw_data[date_ob] = pd.to_datetime(raw_data[date_ob], format='%Y/%m/%d')\n",
"\n",
"object_type = ['Volume(K)','Market Value(M)','Total Stockholders\\' Equity','Total Asset','Net Operating Revenue',\n",
"              'Current liabilities','Current Asset','Cost of Goods Sold','Cash Flow Operating',\n",
"               'Outstanding Shares','Long Term Debt','Net Income']\n",
"\n",
"float_type = ['P/E Ratio-TEJ','Closing Price','Book Value Per Share','Quarter PER']\n",
"for ob in object_type:\n",
"    raw_data[ob] = raw_data[ob].map(lambda x : check_NaN_convert_float(x))\n",
"\n",
"for fl in float_type:\n",
"    raw_data[fl] = raw_data[fl].map(lambda x :  float(str(x).replace(',', '')))\n",
"raw_data[\"Extraordinary Items\"] = raw_data[\"Extraordinary Items\"].map(lambda x :  check_NaN_convert_float(x))\n",
"\n",
"raw_data = raw_data.reset_index(drop=True)\n",
"query_date = []\n",
"for d in raw_data[\"Date\"]:\n",
"    query_date.append(d.strftime(\"%Y-%m\"))\n",
"raw_data = raw_data.join(pd.DataFrame({'query_date': query_date}))"
]
},
{
"cell_type": "markdown",
"metadata": {},
"source": [
"#F-Score 9個因子\n",
"\n",
"ROA=(本期稅後淨利-非常項目)/資產總額  \n",
"**=(Net Income-Extraordinary Items)/Total Asset**  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"\n",
"∆ROA=本期ROA-前期ROA  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"\n",
"CFO=來自營運之現金流量/資產總額  \n",
"**=Cash Flow Operating/Total Asset**  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"\n",
"ACCURAL  \n",
"得分標準：如果CFO>ROA就是一分，否則零分  \n",
"\n",
"∆MARGIN=(營業收入淨額-營業成本)/營業收入淨額  \n",
"**=(Net Operating Revenue-Cost of Goods Sold)/Net Operating Revenue**  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"\n",
"∆TURN=本期TURN - 前期TURN  \n",
"本期TURN=營業收入淨額/((本期資產總額+前期資產總額)/2)  \n",
"**=Net Operating Revenue/((本期Total Asset + 前期Total Asset)/2)**  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"！這個判斷因子會用到三個年度的資料  \n",
"\n",
"∆LEVER=本期LEVER - 前期LEVER  \n",
"本期LEVER=長期負債/((本期資產總額+前期資產總額)/2)  \n",
"**=Long Term Debt/((本期Total Asset + 前期Total Asset)/2)**  \n",
"！這個判斷因子會用到三個年度的資料  \n",
"得分標準：值大於零就是零分，否則一分  \n",
"\n",
"∆LIQUID=流動資產/流動負債  \n",
"**=Current Asset/Current liabilities**  \n",
"得分標準：值大於零就是一分，否則零分  \n",
"\n",
"EQ_OFFER=純粹判斷項  \n",
"得分標準：如果前一年度12月「每股股票股利－股票」Dividend等於零就是一分，否則零分  "
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"# with open('/Users/wy/Desktop/stock_work/stock_Handled.pickle', 'wb') as f:\n",
"#     pickle.dump(raw_data, f)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"# ROA=(本期稅後淨利-非常項目)/資產總額=(Net Income-Extraordinary Items)/Total Asset\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"roa_list = []\n",
"for ni,ei,ta in zip(raw_data['Net Income'],raw_data['Extraordinary Items'],raw_data['Total Asset']):\n",
"    if ta == 0:\n",
"        roa_list.append((ni-ei)/1.)\n",
"    else:\n",
"        roa_list.append((ni-ei)/float(ta))\n",
"            \n",
"# CFO=來自營運之現金流量/資產總額=Cash Flow Operating/Total Asset\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"cfo_list = []\n",
"for cf,ta in zip(raw_data['Cash Flow Operating'],raw_data['Total Asset']):\n",
"    if ta == 0:\n",
"        cfo_list.append(cf/1.)\n",
"    else:\n",
"        cfo_list.append(cf/float(ta))    \n",
"            \n",
"# \"ACCURAL \n",
"# (NI-Ext-CFO)/TA\"\n",
"# 得分標準：值小於零就是一分，否則零分\n",
"accural_list = []\n",
"for ni,ei,ta,cfo in zip(raw_data['Net Income'],raw_data['Extraordinary Items'],\n",
"                    raw_data['Total Asset'],raw_data['Cash Flow Operating']):\n",
"    if ta == 0:\n",
"        accural_list.append((ni-ei-cfo)/1.)\n",
"    else:\n",
"        accural_list.append((ni-ei-cfo)/float(ta))\n",
"\n",
"# LIQUID=流動資產/流動負債\n",
"# \t  =Current Asset/Current liabilities\n",
"liquid_list = []\n",
"for ca,cl in zip(raw_data['Current Asset'],raw_data['Current liabilities']):\n",
"    if cl == 0:\n",
"        liquid_list.append(ca/1.)\n",
"    else:\n",
"        liquid_list.append(ca/float(cl))\n",
"        \n",
"# MARGIN=(營業收入淨額-營業成本)/營業收入淨額\n",
"# \t     =(Net Operating Revenue-Cost of Goods Sold)/Net Operating Revenue\n",
"margin_list = []\n",
"for nor,cgs in zip(raw_data['Net Operating Revenue'],raw_data['Cost of Goods Sold']):\n",
"    if nor == 0 :\n",
"        margin_list.append((nor-cgs)/1.)\n",
"    else:\n",
"        margin_list.append((nor-cgs)/float(nor))            \n",
"\n",
"            \n",
"raw_data = raw_data.join(pd.DataFrame({\"ROA\":roa_list,\"CFO\":cfo_list,\n",
"                                       \"ACCURAL\":accural_list,\"LIQUID\":liquid_list,\n",
"                                       \"MARGIN\":margin_list}))"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"d = {}\n",
"for s in range(len(raw_data)):\n",
"    t = {}\n",
"    for name in [\"query_date\",\"Date\",\"Security Code\",\"ROA\",\"LIQUID\",\"MARGIN\",\"Dividend\",\"Total Asset\"]:\n",
"        t[name] = raw_data[name][s]\n",
"    key = str(raw_data[\"Date\"][s].year)+\"-\"+str(raw_data[\"Date\"][s].month)+\"_\"+raw_data[\"Security Code\"][s]\n",
"    d[key] = t\n",
"    \n",
"# if 本期 - 前期 > 0 -1 else-0\n",
"def cal_delta(value):\n",
"    delta_l = []\n",
"    for c,date,v in zip(raw_data[\"Security Code\"],raw_data[\"Date\"],raw_data[value]):\n",
"        query_last = str(date.year-1)+\"-\"+str(date.month)+\"_\"+c\n",
"        if d.has_key(query_last):\n",
"            last_value =  d[query_last][value]\n",
"            delta_l.append(v - last_value)\n",
"        else:\n",
"            delta_l.append(np.NaN)\n",
"    return delta_l\n",
"\n",
"# if 本期 - 前期 > 0 -1 else-0\n",
"def cal_delta_eq_offer(value):\n",
"    delta_l = []\n",
"    for c,date,v in zip(raw_data[\"Security Code\"],raw_data[\"Date\"],raw_data[value]):\n",
"        query_last = str(date.year-1)+\"-12\"+\"_\"+c\n",
"        if d.has_key(query_last):\n",
"            last_value =  d[query_last][value]\n",
"            delta_l.append(last_value)\n",
"        else:\n",
"            delta_l.append(np.NaN)\n",
"    return delta_l"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"# ∆ROA=本期ROA-前期ROA\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"delta_roa = cal_delta(\"ROA\")\n",
"\n",
"# ∆LIQUID=流動資產/流動負債\n",
"# \t  =Current Asset/Current liabilities\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"delta_liquid = cal_delta(\"LIQUID\")\n",
"\n",
"# ∆MARGIN=(營業收入淨額-營業成本)/營業收入淨額\n",
"# \t     =(Net Operating Revenue-Cost of Goods Sold)/Net Operating Revenue\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"delta_margin = cal_delta(\"MARGIN\")\n",
"\n",
"# 很怪都是0\n",
"# EQ_OFFER=純粹判斷項\n",
"# 得分標準：如果前一年度12月「每股股票股利－股票」Dividend等於零就是一分，否則零分\n",
"eq_offer = cal_delta_eq_offer(\"Dividend\")"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"# ∆LEVER=本期LEVER - 前期LEVER\n",
"# 本期LEVER=長期負債/((本期資產總額+前期資產總額)/2)\n",
"# \t       =Long Term Debt/((本期Total Asset + 前期Total Asset)/2)\n",
"# ！這個判斷因子會用到三個年度的資料\n",
"# 得分標準：值大於零就是零分，否則一分\n",
"\n",
"lever_dict = {}\n",
"for c,date,ltd,ta in zip(raw_data[\"Security Code\"],raw_data[\"Date\"],raw_data['Long Term Debt'],raw_data['Total Asset']):\n",
"    query_last = str(date.year-1)+\"-\"+str(date.month)+\"_\"+c\n",
"    key_now = str(date.year)+\"-\"+str(date.month)+\"_\"+c\n",
"    if d.has_key(query_last):\n",
"        last_ta = d[query_last][\"Total Asset\"]\n",
"        lever_dict[key_now] = (ltd/((ta+last_ta)/2.))\n",
"    else:\n",
"        lever_dict[key_now] = np.NaN\n",
"\n",
"delta_lever = []\n",
"for c,date in zip(raw_data[\"Security Code\"],raw_data[\"Date\"]):\n",
"    key_now = str(date.year)+\"-\"+str(date.month)+\"_\"+c\n",
"    key_last = str(date.year-1)+\"-\"+str(date.month)+\"_\"+c\n",
"    if d.has_key(key_now) and d.has_key(key_last):\n",
"        delta_lever.append(lever_dict[key_now] - lever_dict[key_last])\n",
"    else:\n",
"        delta_lever.append(np.NaN)\n",
"        \n",
"# ∆TURN=本期TURN - 前期TURN\n",
"# 本期TURN=營業收入淨額/((本期資產總額+前期資產總額)/2)\n",
"# \t     =Net Operating Revenue/((本期Total Asset + 前期Total Asset)/2)\n",
"# 得分標準：值大於零就是一分，否則零分\n",
"# ！這個判斷因子會用到三個年度的資料\n",
"\n",
"turn_dict = {}\n",
"for c,date,nor,ta in zip(raw_data[\"Security Code\"],raw_data[\"Date\"],raw_data['Net Operating Revenue'],raw_data['Total Asset']):\n",
"    query_last = str(date.year-1)+\"-\"+str(date.month)+\"_\"+c\n",
"    key_now = str(date.year)+\"-\"+str(date.month)+\"_\"+c\n",
"    if d.has_key(query_last):\n",
"        last_ta = d[query_last][\"Total Asset\"]\n",
"        turn_dict[key_now] = (nor/((ta+last_ta)/2.))\n",
"    else:\n",
"        turn_dict[key_now] = np.NaN\n",
"\n",
"delta_turn = []\n",
"for c,date in zip(raw_data[\"Security Code\"],raw_data[\"Date\"]):\n",
"    key_now = str(date.year)+\"-\"+str(date.month)+\"_\"+c\n",
"    key_last = str(date.year-1)+\"-\"+str(date.month)+\"_\"+c\n",
"    if d.has_key(key_now) and d.has_key(key_last):\n",
"        delta_turn.append((turn_dict[key_now] - turn_dict[key_last]))\n",
"    else:\n",
"        delta_turn.append(np.NaN)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"df_roa = [1 if v > 0 else 0 for v in raw_data['ROA']]\n",
"df_cfo = [1 if v > 0 else 0 for v in raw_data['CFO']]\n",
"df_accural = [1 if v < 0 else 0 for v in raw_data['ACCURAL']]\n",
"df_delta_roa = [1 if v > 0 else 0 for v in delta_roa]\n",
"df_delta_margin = [1 if v > 0 else 0 for v in delta_margin]\n",
"df_delta_turn = [1 if v > 0 else 0 for v in delta_turn]\n",
"df_delta_lever = [1 if v < 0 else 0 for v in delta_lever]\n",
"df_delta_liquid = [1 if v > 0 else 0 for v in delta_liquid]\n",
"\n",
"df_eq_offer = []\n",
"for v in eq_offer:\n",
"    if str(v) == 'nan':\n",
"        df_eq_offer.append(1)\n",
"    else:\n",
"        if v == 0.:\n",
"            df_eq_offer.append(1)\n",
"        else:\n",
"            df_eq_offer.append(0)\n",
"\n",
"raw_data = raw_data.drop('ROA', 1)\n",
"raw_data = raw_data.drop('CFO', 1)\n",
"raw_data = raw_data.drop('ACCURAL', 1)\n",
"raw_data = raw_data.drop('LIQUID', 1)\n",
"raw_data = raw_data.drop('MARGIN', 1)\n",
"raw_data = raw_data.drop('query_date', 1)\n",
"\n",
"# 把九個因子加入DataFrame，並計算f-score\n",
"raw_data = raw_data.join(pd.DataFrame({\"delta_roa\":df_delta_roa,\"delta_liquid\":df_delta_liquid\n",
"                                       ,\"delta_margin\":df_delta_margin,\"eq_offer\":df_eq_offer,\n",
"                                       \"delta_lever\":df_delta_lever,\"delta_turn\":df_delta_turn,\n",
"                                       'ROA':df_roa,'CFO':df_cfo,'ACCURAL':df_accural\n",
"                                      }))\n",
"# 算 F-Score\n",
"f_score_name = zip(raw_data[\"delta_lever\"],raw_data[\"delta_liquid\"],raw_data['delta_margin'],raw_data['delta_roa'],\n",
"    raw_data[\"delta_turn\"],raw_data[\"eq_offer\"],raw_data[\"ACCURAL\"],raw_data[\"CFO\"],raw_data[\"ROA\"])\n",
"\n",
"fscore_list = []\n",
"for a,b,c,d,e,f,g,h,t in f_score_name:\n",
"    if np.NaN in [a,b,c,d,e,f,g,h,t]:\n",
"        fscore_list.append(np.NaN)\n",
"    else:\n",
"        fscore_list.append(sum([a,b,c,d,e,f,g,h,t]))\n",
"raw_data = raw_data.join(pd.DataFrame({\"F-Score\":fscore_list}))"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": false
},
"outputs": [],
"source": [
"with open('/Users/wy/Desktop/stock_work/stock_Handled.pickle', 'wb') as f:\n",
"    pickle.dump(raw_data, f)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": [
"raw_data.to_csv('/Users/wy/Desktop/stock_work/stock_Handled_v4.csv',index=False)"
]
},
{
"cell_type": "code",
"execution_count": null,
"metadata": {
"collapsed": true
},
"outputs": [],
"source": []
}
],
"metadata": {
"kernelspec": {
"display_name": "Python 2",
"language": "python",
"name": "python2"
},
"language_info": {
"codemirror_mode": {
"name": "ipython",
"version": 2
},
"file_extension": ".py",
"mimetype": "text/x-python",
"name": "python",
"nbconvert_exporter": "python",
"pygments_lexer": "ipython2",
"version": "2.7.11"
}
},
"nbformat": 4,
"nbformat_minor": 0
}
plot(pressure)
plot(pressure, type="l")
plot(x, y.democr, type="l", col="blue")
x1 <- rnorm(10)
x2 <- rnorm(10)
y1 <- rexp(10)
y2 <- rexp(10)
plot(x1, y1, type="l")
lines(x2, y2, lty="dashed")
xlim <- range(c(x1, x2))
ylim <- range(c(y1, y2))
plot(x1, y1, type="l", xlim=xlim, ylim=ylim)
lines(x2, y2, lty="dashed")
